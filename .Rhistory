lme.h<- update(lme.g,.~.-Colour.difference:background -
(1+Colour.difference*background|batch) +
+ (1+Colour.difference+background|batch) )#2way
formula(lme.h)
lme.i<- update(lme.h,.~.-background:target)#2way
formula(lme.i)
lme.j<- update(lme.i, ~.-Colour.difference:target  )#2way
formula(lme.j)
lme.k<- update(lme.j,.~.-target:sex)#2way
formula(lme.k)
lme.l<- update(lme.k,.~.-background -
(1+Colour.difference+background|batch) +
(1+Colour.difference|batch) )#1way
formula(lme.l)
lme.m<- update(lme.l,.~.-sex)#1way
formula(lme.m)
lme.n<- update(lme.m,.~.-target)#1way
formula(lme.n)
lme.o<- update(lme.n,.~.-Colour.difference -
(1+Colour.difference|chick) +
(1+Colour.difference|batch) -
(1|chick) + (1|batch) )
formula(lme.o)#same as lme0, no fixed effects left to remove
anova(lme2, lme.a, lme.b, lme.c, lme.d, lme.e, lme.f, lme.g, lme.h, lme.i, lme.j, lme.k, lme.l, lme.m, lme.n, lme.o)
anova(lme2, lme.a, lme.b, lme.c, lme.d, lme.e, lme.f, lme.g, lme.h, lme.i, lme.j, lme.k, lme.l, lme.m, lme.n, lme.o)[order(row.names(anova(lme2, lme.a, lme.b, lme.c, lme.d, lme.e, lme.f, lme.g, lme.h, lme.i, lme.j, lme.k, lme.l, lme.m, lme.n, lme.o))),]
anova(lme2, lme.a, lme.b, lme.c, lme.d, lme.e, lme.f, lme.g, lme.h, lme.i, lme.j, lme.k, lme.l, lme.m, lme.n, lme.o)[rev(order(AIC(lme2, lme.a, lme.b, lme.c, lme.d, lme.e, lme.f, lme.g, lme.h, lme.i, lme.j, lme.k, lme.l, lme.m, lme.n, lme.o)$AIC)),]
anova(lme2, lme.a)
xseq <- unique(data$Colour.difference) # imaginary stimulus levels to fit to. Change the high and low values, the two values after seq(,  to fit to your datas stimulus levels
newdata <- expand.grid(Colour.difference =xseq, background=unique(data$background),target=unique(data$target), sex = unique(data$sex), chick = unique(data$chick), batch = unique(data$batch))
lme1.pred <- predict(lme2, newdata = data.frame(Colour.difference = data$Colour.difference, background = data$background, target = data$target, sex = data$sex), type="response", re.form = NA)#,se.fit=TRUE) ##Setting up the real data from the function
lme2.pred <- predict(lme2, newdata = newdata, type="response")#,se.fit=TRUE) ## Setting up the imaginary data from the function
plot(data$Colour.difference, lme1.pred)
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
if(bk == 'green' & tg == 'same'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}#if(bg == 'green' & tg == 'same')
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = 2*which(unique(subset(data, chick == ck)$sex) == levels(newdata$sex)), lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
}#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
}#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
}#for(i in 1:dim(bktg)[1]){
# }#	for(tg in levels(newdata$target)){
# }#for(bk in levels(data$background))
cls <- c( "purple4",
"slateblue3",
"slateblue2",
"red3",
"green3",
"slateblue1",
"pink3"     ,
"orange3"  ,
"navajowhite4",
"gray50"     ,
"gray70" ,
"gray30" ,
"darkblue"  ,
"navajowhite2",
"orange4"     ,
"steelblue"  ,
"gray10"   ,
"purple3"   ,
"magenta4"   ,
"slateblue4"  ,
"green2"   ,
"blue2"    ,
"darkred"    ,
"darkgreen"  ,
"orange2"     ,
"seagreen"    ,
"salmon4"   ,
"navajowhite1" ,
"navajowhite3" ,
"yellow3"     ,
"blue3",
"magenta3")
AF <- function(x){as.factor(x)}
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
# for(bk in levels(data$background)){
# for(tg in rev(levels(newdata$target))){
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
legend(4, .7, levels(AF(data$chick[data$target == tg & data$background == bk])), col = cls[which(	levels(AF(data$chick)) %in% levels(AF(data$chick[data$target == tg & data$background == bk])))], pch = c(22,24)[as.numeric(data$sex[data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) & data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))] )],
cex = 1, bty = 'n', lwd = 1, lty = as.numeric( subset(data, chick %in% levels(AF(data$chick[data$target == tg & data$background == bk])) & data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) )$batch ) )
if(bk == 'green' & tg == 'diff'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}#if(bg == 'green' & tg == 'same')
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = cls[which(levels(AF(data$chick)) == ck)], lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
points(data$Colour.difference[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], data$pcorr[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg & data$chick == ck])], bg = 'white', col = cls[which(levels(AF(data$chick)) == ck)], lwd = 2)
}#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
}#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
}#for(i in 1:dim(bktg)[1])
# }#	for(tg in levels(newdata$target)){
# }#for(bk in levels(data$background))
ndata <- expand.grid(Colour.difference =xseq, background=unique(data$background), target=unique(data$target))
prd <- predict(lme2, newdata = newdata, type="response", re.form = NA)
#bootstrap the confidence intervals (can take a while...)
pfun <- function(x){predict(x, newdata = newdata, type = 'response')}
boot <- bootMer(lme2, pfun, nsim = 10^2, re.form = NA, parallel = c("multicore"), ncpus = parallel::detectCores())
stqlog	 <- function(x){ sd(qlogis(x), na.rm = T)}
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo <- plogis(qlogis(prd) - std.err*1.96)#lower confidence bound (parametric)
CI.hi <- plogis(qlogis(prd) + std.err*1.96)#upper confidence bound (parametric)
bootsdata <- cbind(newdata, CI.lo, CI.hi)
CI.lo. <- with(bootsdata, aggregate(CI.lo, list(Colour.difference = Colour.difference, background = background, target = target), mean))
CI.hi. <- with(bootsdata, aggregate(CI.hi, list(Colour.difference = Colour.difference, background = background, target = target), mean))
ciii <- confint(boot, parallel = c("multicore"),ncpus = parallel::detectCores())
paramdata <- cbind(newdata, ciii)
#mean should be in logit space
lgtmean <- function(x){plogis(mean(qlogis(x)))}
CI.02.5 <- with(paramdata, aggregate(`2.5 %`, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))#mean))
CI.97.5 <- with(paramdata, aggregate(`97.5 %`, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))#mean))
estdata <- cbind(newdata, prd)[order(newdata$Colour.difference),]
estcurve <- with(estdata, aggregate(prd, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
threshquant <- list(same = (0:20/100), diff = (0:40/100))
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
suppressWarnings(
dev.copy(pdf, paste0(Sys.getenv('HOME'),'/Dropbox/Colour discrimination on chromatic backgrounds/Data/for GLMM/',
'full mixed fixed CI-nonpsych','checked','.pdf'),
width= par("din")[1], height= par("din")[2], useDingbats = F)	);
save.image("C:/Users/seano/Github/Olsson_colour_discrimination/Non-psychometric_MLE.Rdata.RData")
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
);
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
dev.set(dev.prev())
#find 65% threshold and standard errors
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
#dev.set(dev.prev())
#find 65% threshold and standard errors
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
legend(4, .7, levels(AF(data$chick[data$target == tg & data$background == bk])), col = cls[which(	levels(AF(data$chick)) %in% levels(AF(data$chick[data$target == tg & data$background == bk])))], pch = c(22,24)[as.numeric(data$sex[data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) & data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))] )],
cex = 1, bty = 'n', lwd = 1, lty = as.numeric( subset(data, chick %in% levels(AF(data$chick[data$target == tg & data$background == bk])) & data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) )$batch ) )
if(bk == 'green' & tg == 'diff'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = cls[which(levels(AF(data$chick)) == ck)], lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
points(data$Colour.difference[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], data$pcorr[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg & data$chick == ck])], bg = 'white', col = cls[which(levels(AF(data$chick)) == ck)], lwd = 2)
}
}
}
ndata <- expand.grid(Colour.difference =xseq, background=unique(data$background), target=unique(data$target))
prd <- predict(lme2, newdata = newdata, type="response", re.form = NA)
pfun <- function(x){predict(x, newdata = newdata, type = 'response')}
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
legend(4, .7, levels(AF(data$chick[data$target == tg & data$background == bk])), col = cls[which(	levels(AF(data$chick)) %in% levels(AF(data$chick[data$target == tg & data$background == bk])))], pch = c(22,24)[as.numeric(data$sex[data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) & data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))] )],
cex = 1, bty = 'n', lwd = 1, lty = as.numeric( subset(data, chick %in% levels(AF(data$chick[data$target == tg & data$background == bk])) & data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) )$batch ) )
if(bk == 'green' & tg == 'diff'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = cls[which(levels(AF(data$chick)) == ck)], lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
points(data$Colour.difference[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], data$pcorr[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg & data$chick == ck])], bg = 'white', col = cls[which(levels(AF(data$chick)) == ck)], lwd = 2)
}
}
}
ndata <- expand.grid(Colour.difference =xseq, background=unique(data$background), target=unique(data$target))
prd <- predict(lme2, newdata = newdata, type="response", re.form = NA)
pfun <- function(x){predict(x, newdata = newdata, type = 'response')}
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
thresholder <- function(xx,yy,lev){
diff. <- sort(yy-lev)
close. <- min(abs(diff.))
if(sign(diff.[abs(diff.) == close.]) == 0){
return(	xx[which(abs(diff.) == close.) + c(0)]	)
}else{
if(sign(diff.[abs(diff.) == close.]) == 1){
if(which(abs(diff.) == close.) == 1){
return(	xx[1])
}else{
ab. <-  xx[which(abs(diff.) == close.) + c(-1,0)]
}
}else{
ab. <-  xx[which(abs(diff.) == close.) + c(0,1)]
}#if(sign(diff.[abs(diff.) == close.]) == 1)
ty. <- yy[xx %in% ab.]
xxt. <- seq(min(ab.), max(ab.), length.out = 10^3)
yyt. <- (xxt.-min(ab.))*diff(ty.)/diff(ab.) + min(ty.)
return(	mean(xxt.[round(yyt.,2) == lev])	)
}
}
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct",
xlim=c(0, 6),  ylim=c(0.4, 1),
main = paste('background =',bk, ', target =', tg))
abline(h = 0.65, lty = 2, lwd = 0.5)
x1 <- subset(estcurve, background == bk & target == tg)$Colour.difference
y1 <- subset(estcurve, background == bk & target == tg)$x
xx <- sort(unique(subset(CI.lo.se., background == bk & target==tg)$Colour.difference ))
yy.lo <- sort(unique(	subset(CI.lo.se., background == bk & target == tg)$x	))
yy.hi <- sort(unique(	subset(CI.hi.se., background == bk & target == tg)$x	))
lines(xx, yy.lo)
lines(xx, yy.hi)
lines(x1, y1, col = 'darkgreen')
assign(paste0('t.', tg, bk), thresholder(x1,y1,0.65))
lines(rep(get(paste0('t.', tg, bk)),2), c(0.38, 0.65), lty = 2, col = 'green')
assign(paste0('t.se.lo.', tg, bk), thresholder(xx,yy.hi,0.65))
lines(rep(get(paste0('t.se.lo.', tg, bk)),2), c(0.38, 0.65), lty = 2,col ='red')
assign(paste0('t.se.hi.', tg, bk), thresholder(xx,yy.lo,0.65))
lines(rep(get(paste0('t.se.hi.', tg, bk)),2), c(0.38, 0.65), lty = 2,col ='blue')
}
#the "binomial" 65% threshold
#JND for chickens discriminating orange colours on an orange background
round(	c(	t.sameorange,
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
)
#JND on a green background
round(	c(	t.diffgreen,
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
round(	c(	t.sameorange,
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
)
round(	c(	t.diffgreen,
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
t.sameorange
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2))
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
diff(round(	c(
t.se.lo.samegreen,
t.se.hi.samegreen	),	2)
)
diff(round(	c(
t.se.lo.difforange,
t.se.hi.difforange	),	2)
)
save.image("C:/Users/seano/Github/Olsson_colour_discrimination/Non-psychometric_MLE.Rdata.RData")
