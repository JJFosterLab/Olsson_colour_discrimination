# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
suppressWarnings(
dev.copy(pdf, paste0(Sys.getenv('HOME'),'/Dropbox/Colour discrimination on chromatic backgrounds/Data/for GLMM/',
'full mixed fixed CI-nonpsych','checked','.pdf'),
width= par("din")[1], height= par("din")[2], useDingbats = F)	);
save.image("C:/Users/seano/Github/Olsson_colour_discrimination/Non-psychometric_MLE.Rdata.RData")
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
);
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
dev.set(dev.prev())
#find 65% threshold and standard errors
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
#dev.set(dev.prev())
#find 65% threshold and standard errors
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
legend(4, .7, levels(AF(data$chick[data$target == tg & data$background == bk])), col = cls[which(	levels(AF(data$chick)) %in% levels(AF(data$chick[data$target == tg & data$background == bk])))], pch = c(22,24)[as.numeric(data$sex[data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) & data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))] )],
cex = 1, bty = 'n', lwd = 1, lty = as.numeric( subset(data, chick %in% levels(AF(data$chick[data$target == tg & data$background == bk])) & data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) )$batch ) )
if(bk == 'green' & tg == 'diff'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = cls[which(levels(AF(data$chick)) == ck)], lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
points(data$Colour.difference[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], data$pcorr[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg & data$chick == ck])], bg = 'white', col = cls[which(levels(AF(data$chick)) == ck)], lwd = 2)
}
}
}
ndata <- expand.grid(Colour.difference =xseq, background=unique(data$background), target=unique(data$target))
prd <- predict(lme2, newdata = newdata, type="response", re.form = NA)
pfun <- function(x){predict(x, newdata = newdata, type = 'response')}
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
legend(4, .7, levels(AF(data$chick[data$target == tg & data$background == bk])), col = cls[which(	levels(AF(data$chick)) %in% levels(AF(data$chick[data$target == tg & data$background == bk])))], pch = c(22,24)[as.numeric(data$sex[data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) & data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))] )],
cex = 1, bty = 'n', lwd = 1, lty = as.numeric( subset(data, chick %in% levels(AF(data$chick[data$target == tg & data$background == bk])) & data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) )$batch ) )
if(bk == 'green' & tg == 'diff'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = cls[which(levels(AF(data$chick)) == ck)], lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
points(data$Colour.difference[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], data$pcorr[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg & data$chick == ck])], bg = 'white', col = cls[which(levels(AF(data$chick)) == ck)], lwd = 2)
}
}
}
ndata <- expand.grid(Colour.difference =xseq, background=unique(data$background), target=unique(data$target))
prd <- predict(lme2, newdata = newdata, type="response", re.form = NA)
pfun <- function(x){predict(x, newdata = newdata, type = 'response')}
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
thresholder <- function(xx,yy,lev){
diff. <- sort(yy-lev)
close. <- min(abs(diff.))
if(sign(diff.[abs(diff.) == close.]) == 0){
return(	xx[which(abs(diff.) == close.) + c(0)]	)
}else{
if(sign(diff.[abs(diff.) == close.]) == 1){
if(which(abs(diff.) == close.) == 1){
return(	xx[1])
}else{
ab. <-  xx[which(abs(diff.) == close.) + c(-1,0)]
}
}else{
ab. <-  xx[which(abs(diff.) == close.) + c(0,1)]
}#if(sign(diff.[abs(diff.) == close.]) == 1)
ty. <- yy[xx %in% ab.]
xxt. <- seq(min(ab.), max(ab.), length.out = 10^3)
yyt. <- (xxt.-min(ab.))*diff(ty.)/diff(ab.) + min(ty.)
return(	mean(xxt.[round(yyt.,2) == lev])	)
}
}
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct",
xlim=c(0, 6),  ylim=c(0.4, 1),
main = paste('background =',bk, ', target =', tg))
abline(h = 0.65, lty = 2, lwd = 0.5)
x1 <- subset(estcurve, background == bk & target == tg)$Colour.difference
y1 <- subset(estcurve, background == bk & target == tg)$x
xx <- sort(unique(subset(CI.lo.se., background == bk & target==tg)$Colour.difference ))
yy.lo <- sort(unique(	subset(CI.lo.se., background == bk & target == tg)$x	))
yy.hi <- sort(unique(	subset(CI.hi.se., background == bk & target == tg)$x	))
lines(xx, yy.lo)
lines(xx, yy.hi)
lines(x1, y1, col = 'darkgreen')
assign(paste0('t.', tg, bk), thresholder(x1,y1,0.65))
lines(rep(get(paste0('t.', tg, bk)),2), c(0.38, 0.65), lty = 2, col = 'green')
assign(paste0('t.se.lo.', tg, bk), thresholder(xx,yy.hi,0.65))
lines(rep(get(paste0('t.se.lo.', tg, bk)),2), c(0.38, 0.65), lty = 2,col ='red')
assign(paste0('t.se.hi.', tg, bk), thresholder(xx,yy.lo,0.65))
lines(rep(get(paste0('t.se.hi.', tg, bk)),2), c(0.38, 0.65), lty = 2,col ='blue')
}
#the "binomial" 65% threshold
#JND for chickens discriminating orange colours on an orange background
round(	c(	t.sameorange,
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
)
#JND on a green background
round(	c(	t.diffgreen,
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
round(	c(	t.sameorange,
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
)
round(	c(	t.diffgreen,
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
t.sameorange
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2))
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
diff(round(	c(
t.se.lo.samegreen,
t.se.hi.samegreen	),	2)
)
diff(round(	c(
t.se.lo.difforange,
t.se.hi.difforange	),	2)
)
save.image("C:/Users/seano/Github/Olsson_colour_discrimination/Non-psychometric_MLE.Rdata.RData")
knitr::opts_chunk$set(echo = TRUE)
#install.packages(c('boot','nonpsych4','MASS','nonpsychrTest','DHARMa'))
library(readr)
library(boot)
library(lme4)
library(MASS)
library(nonpsychrTest)
knitr::opts_chunk$set(echo = TRUE)
library('readr')
library('boot')
library('lme4')
library('MASS')
library('lmerTest')
library('DHARMa')
col.dta <- read_delim('colour_discriminate_short_format.txt', delim='\t')
data <- col.dta
data$stimuli <- factor(data$stimuli)
data$target <- with(data, ifelse(background == stimuli, 'same', 'diff'))
data$target <- as.factor(data$target)
data$background <- factor(data$background)
data$ind <- factor(data$ind)
data$batch <- as.factor(data$batch)
data$chick <- paste0(data$ind, data$batch)
resplot <- function(mod){
#are residuals normally distributed
hist(residuals(mod), prob = T, xlab = formula(mod), main = paste('Residuals for',(formula(mod)[3])))# this actually looks OK to me
lines(density(residuals(mod)), col = 'red')
lines(seq(min(residuals(mod)),max(residuals(mod)), length.out = 10^3), dnorm(seq(min(residuals(mod)),max(residuals(mod)), length.out = 10^3), 0, sd(residuals(mod))), col = 'blue')
legend('topright', legend = c('kernel density', 'fitted normal'), lty = 1, col = c('red', 'blue'))
boxplot(residuals(mod),
add = T, axes = F, horizontal = T, cex = 0.5, outline = T, border = rgb(0,0.1,0,0.7), at = par('yaxp')[2]*0.1,
pars = list(boxwex = par('yaxp')[2]*0.3, staplewex = par('yaxp')[2]*0.5, outwex = par('yaxp')[2]*0.05))#
}
nonpsych1 <- glmer(cbind(corr,incorr)~Colour.difference*background*target*sex + (1+Colour.difference|chick)+ (1+Colour.difference*background|batch), data = data, family = binomial(link = 'logit'))
print(.Machine$double.eps * 10^8)
nonpsych2 <- glmer(cbind(corr,incorr)~Colour.difference*background*target*sex + (1+Colour.difference|chick)+ (1+Colour.difference*background|batch), data = data, family = binomial(link = 'logit'), control = glmerControl(tol = .Machine$double.eps * 10^8))
nonpsych0 <- glmer(cbind(corr,incorr)~1 + (1|chick)+ (1|batch), data = data, family = binomial(link = 'logit'))
anova(nonpsych0, nonpsych1, nonpsych2, test = 'Chisq')
anova(nonpsych0, nonpsych2, test = 'Chisq')
AIC(nonpsych0, nonpsych1, nonpsych2) #
resplot(nonpsych2)#looks good
shapiro.test(residuals(nonpsych2)) # even passes a Shapiro-Wilk test
simulateResiduals(nonpsych2,  n=10^3, plot = T, refit = T)
mtext(formula(nonpsych2), side = 3, outer = F, line = 1)
summary(nonpsych2)
anova(nonpsych2)[order(anova(nonpsych2)$`F value`),]
nonpsych.a<- update(nonpsych2,.~.-Colour.difference:background:target:sex)#4way
formula(nonpsych.a)
nonpsych.b<- update(nonpsych.a,.~.-Colour.difference:target:sex)#3way
formula(nonpsych.b)
nonpsych.c<- update(nonpsych.b,.~.-Colour.difference:background:sex )#3way
formula(nonpsych.c)
nonpsych.d<- update(nonpsych.c,.~.-Colour.difference:background:target )#3way
load("C:/Users/seano/Github/Olsson_colour_discrimination/Non-psychometric_MLE/Non-psychometric_MLE.RData")
t.se.hi.diffgreen
library(rstan)
knitr::opts_chunk$set(echo = TRUE)
library('rstan')
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
library('brms')
getwd()
knitr::opts_chunk$set(echo = TRUE)
library('rstan')
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
library('brms')
col.dta <- read.txt('colour_discriminate_short_format.txt')
help("read.delim")
col.dta <- read.delim('colour_discriminate_short_format.txt',sep="\t")
getwd()
library('readr')
library('rstan')
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
library('brms')
col.dta <- read_delim('colour_discriminate_short_format.txt',delim="\t")
col.dta <- read_delim('../colour_discriminate_short_format.txt',delim="\t")
cd.long <- read_delim('../colour_discriminate_long_format.txt', delim="\t")
head(cd.long)
cd.long$target <- ifelse(cd.long$target.same, 'same', 'diff')
cd.long$target <- as.factor(cd.long$target)#this is a factor
cd.long$chick <- as.factor(cd.long$chick)#chick is also a factor
levels(cd.long$target)#different is the default reference level
levels(cd.long$target)
cd.long$target <- relevel(cd.long$target,'same')
levels(cd.long$background)
cd.long$background
str(cd.long$background)
cd.long$background <- as.factor(cd.long$background)
levels(cd.long$background)
cd.long$target <- ifelse(cd.long$target.same, 'same', 'diff')
cd.long$target <- as.factor(cd.long$target)#this is a factor
levels(cd.long$target)
cd.long$chick  <- as.factor(cd.long$chick)#chick is also a factor
knitr::opts_chunk$set(echo = TRUE)
library('readr')
library('rstan')
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
library('brms')
cd.long <- read_delim('colour_discriminate_long_format.txt', delim="\t")
head(cd.long)
cd.long$chick  <- as.factor(cd.long$chick)#chick is also a factor
cd.long$target <- ifelse(cd.long$target.same, 'same', 'diff')
cd.long$target <- as.factor(cd.long$target)#this is a factor
levels(cd.long$target)
cd.long$target <- relevel(cd.long$target,'same')
cd.long$background <- as.factor(cd.long$background)
levels(cd.long$background)
modnm1 <- 'TW.Model-bg_target_REVISION'#distinguish it from others
frm1 <-              bf(
formula = success ~ base	 +	#guess rate
(1-inv_logit(lapse)-base) 	* #curve region
inv_logit(0++4.39*(	Colour.difference-exp(threshold)	) 	/
(	exp(width)	)), #threshold-width curve
base ~ 1, #baseline has a single mean
lapse ~ 1 + (1|chick) +(1|batch),  #lapse rate depends on chick
#threshold coef depend on fixef & chick
threshold ~ background*target*sex +(1|chick) +(1|batch),
#width coef depend on fixef & chick
width ~ background*target*sex +(1|chick) +(1|batch),
nl = TRUE)#the joint distribution for these parameters is undefined, and therefore the parameters themselves are "nonlinear"
get_prior(frm1, data = cd.long)[,c('class', 'coef','nlpar', 'group')]
prr1 <- c(
#very restrictive prior for guess rate, centred on 0.5
prior(beta(250,250), nlpar= 'base', lb = 0.25, ub = 0.75),
#lapse rate is unbiased, but cannot be more than 27%
prior(normal(-3,10), nlpar= 'lapse', ub = -1),
# use the default prior for random effects of lapse:
#	student_t(3, 0, 10)),
# this can be done by leaving:
#	prior(... nlpar= 'lapse', class= sd), unassigned
#Both threshold and width should be positive numbers, probably ≈1
#i.e. exp(0) = 1
#beware, bounds on threshold and width priors
#affect their coefficients (so don't apply bounds)
prior(normal(0,10), nlpar= 'threshold', class = 'b'),
prior(normal(0,10), nlpar = 'width', class = 'b'),
#Coefficient parameters, centred on 0
#(<0 = param smaller, >0 = param larger)
prior(normal(0,10), nlpar= 'threshold', coef= 'backgroundorange'),
prior(normal(0,10), nlpar= 'threshold', coef= 'targetdiff'),
prior(normal(0,10), nlpar= 'threshold', coef= 'backgroundorange:targetdiff'),
# use the default prior for random effects of threshold, unassigned
prior(normal(0,10), nlpar= 'width', coef= 'backgroundorange'),
prior(normal(0,10), nlpar= 'width', coef= 'targetdiff'),
prior(normal(0,10), nlpar= 'width', coef= 'backgroundorange:targetdiff')#,
# use the default prior for random effects of width, unassigned
)
stc1 <- make_stancode(
formula = frm1,
data = cd.long, family = bernoulli("identity"),
prior = prr1 )
stc1
TW_col.dta1 <- brm( formula = frm1,
data = cd.long, family = bernoulli("identity"),
prior = prr1,
#finely sampled
control = list(adapt_delta = 0.99),
inits = 0,
iter = 1000  )
TW_col.dta1 <- readRDS("C:/Users/seano/Github/Olsson_colour_discrimination/Bayesian Psychometric/Bayesian_psychometic_model_object.rds")
pp_check(TW_col.dta1,
type = "rootogram", nsamples=2000, prob = 0.9, size = 1)
summary(TW_col.dta1)
plot(TW_col.dta1)
mcmc_plot(TW_col.dta1)
brms::mcmc_plot()
help("mcmc_plot")
mcmc_plot(TW_col.dta1,type="by_chain")
plot(TW_col.dta1,type="combo")
plot(TW_col.dta1,type="dens_overlay")
plot(TW_col.dta1,type="dens_overlay", pars = "^b_")
