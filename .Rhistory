"slateblue2",
"red3",
"green3",
"slateblue1",
"pink3"     ,
"orange3"  ,
"navajowhite4",
"gray50"     ,
"gray70" ,
"gray30" ,
"darkblue"  ,
"navajowhite2",
"orange4"     ,
"steelblue"  ,
"gray10"   ,
"purple3"   ,
"magenta4"   ,
"slateblue4"  ,
"green2"   ,
"blue2"    ,
"darkred"    ,
"darkgreen"  ,
"orange2"     ,
"seagreen"    ,
"salmon4"   ,
"navajowhite1" ,
"navajowhite3" ,
"yellow3"     ,
"blue3",
"magenta3")
AF <- function(x){as.factor(x)}
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
# for(bk in levels(data$background)){
# for(tg in rev(levels(newdata$target))){
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
legend(4, .7, levels(AF(data$chick[data$target == tg & data$background == bk])), col = cls[which(	levels(AF(data$chick)) %in% levels(AF(data$chick[data$target == tg & data$background == bk])))], pch = c(22,24)[as.numeric(data$sex[data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) & data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))] )],
cex = 1, bty = 'n', lwd = 1, lty = as.numeric( subset(data, chick %in% levels(AF(data$chick[data$target == tg & data$background == bk])) & data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) )$batch ) )
if(bk == 'green' & tg == 'diff'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}#if(bg == 'green' & tg == 'same')
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = cls[which(levels(AF(data$chick)) == ck)], lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
points(data$Colour.difference[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], data$pcorr[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg & data$chick == ck])], bg = 'white', col = cls[which(levels(AF(data$chick)) == ck)], lwd = 2)
}#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
}#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
}#for(i in 1:dim(bktg)[1])
# }#	for(tg in levels(newdata$target)){
# }#for(bk in levels(data$background))
ndata <- expand.grid(Colour.difference =xseq, background=unique(data$background), target=unique(data$target))
prd <- predict(lme2, newdata = newdata, type="response", re.form = NA)
#bootstrap the confidence intervals (can take a while...)
pfun <- function(x){predict(x, newdata = newdata, type = 'response')}
boot <- bootMer(lme2, pfun, nsim = 10^2, re.form = NA, parallel = c("multicore"), ncpus = parallel::detectCores())
stqlog	 <- function(x){ sd(qlogis(x), na.rm = T)}
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo <- plogis(qlogis(prd) - std.err*1.96)#lower confidence bound (parametric)
CI.hi <- plogis(qlogis(prd) + std.err*1.96)#upper confidence bound (parametric)
bootsdata <- cbind(newdata, CI.lo, CI.hi)
CI.lo. <- with(bootsdata, aggregate(CI.lo, list(Colour.difference = Colour.difference, background = background, target = target), mean))
CI.hi. <- with(bootsdata, aggregate(CI.hi, list(Colour.difference = Colour.difference, background = background, target = target), mean))
ciii <- confint(boot, parallel = c("multicore"),ncpus = parallel::detectCores())
paramdata <- cbind(newdata, ciii)
#mean should be in logit space
lgtmean <- function(x){plogis(mean(qlogis(x)))}
CI.02.5 <- with(paramdata, aggregate(`2.5 %`, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))#mean))
CI.97.5 <- with(paramdata, aggregate(`97.5 %`, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))#mean))
estdata <- cbind(newdata, prd)[order(newdata$Colour.difference),]
estcurve <- with(estdata, aggregate(prd, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
threshquant <- list(same = (0:20/100), diff = (0:40/100))
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
suppressWarnings(
dev.copy(pdf, paste0(Sys.getenv('HOME'),'/Dropbox/Colour discrimination on chromatic backgrounds/Data/for GLMM/',
'full mixed fixed CI-nonpsych','checked','.pdf'),
width= par("din")[1], height= par("din")[2], useDingbats = F)	);
save.image("C:/Users/seano/Github/Olsson_colour_discrimination/Non-psychometric_MLE.Rdata.RData")
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
);
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
dev.set(dev.prev())
#find 65% threshold and standard errors
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
hw <- c(2,2)
#7.426829 inches wide, 11.060975 inches tall on my large screen
#no crazy margins if we want it to match Peter's
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
# for(bk in levels(newdata$background)){
# for(tg in rev(levels(newdata$target))){
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
# for(bc in levels(newdata$batch)){
# for(sx in levels(newdata$sex)){
# for(ck in levels(newdata$chick)){
# if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck)){
# xx <- (subset(newdata, background == bk & target == tg)$Colour.difference)
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
# xx <- xx0[xx0 %in% subset(data, background == bk & target == tg)$Colour.difference]
# yy <-(prd[newdata$background == bk & newdata$target == tg])[1:length(xx)]
# ORDER <- order(xx)#check that this works w/ CI
# polygon(c(subset(CI.lo., background == bk)$Colour.difference, rev(subset(CI.hi., background == bk)$Colour.difference)), c(subset(CI.lo., background == bk)$x,rev(subset(CI.hi., background == bk)$x)) , col = 'blue', border = rgb(0,0,0,0))
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
# }#if(sum(newdata$background == bk & newdata$sex == sx & newdata$batch == bc & newdata$chick == ck))#
# }#for(ck in levels(data$chick))
# }#for(sx in levels(data$sex))
# }#for(bc in levels(data$batch))
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}#for(i in 1:dim(bktg)[1]){
# }#		for(tg in rev(levels(newdata$target))){
# }#for(bk in levels(data$background))
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
#dev.set(dev.prev())
#find 65% threshold and standard errors
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
legend(4, .7, levels(AF(data$chick[data$target == tg & data$background == bk])), col = cls[which(	levels(AF(data$chick)) %in% levels(AF(data$chick[data$target == tg & data$background == bk])))], pch = c(22,24)[as.numeric(data$sex[data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) & data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))] )],
cex = 1, bty = 'n', lwd = 1, lty = as.numeric( subset(data, chick %in% levels(AF(data$chick[data$target == tg & data$background == bk])) & data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) )$batch ) )
if(bk == 'green' & tg == 'diff'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = cls[which(levels(AF(data$chick)) == ck)], lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
points(data$Colour.difference[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], data$pcorr[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg & data$chick == ck])], bg = 'white', col = cls[which(levels(AF(data$chick)) == ck)], lwd = 2)
}
}
}
ndata <- expand.grid(Colour.difference =xseq, background=unique(data$background), target=unique(data$target))
prd <- predict(lme2, newdata = newdata, type="response", re.form = NA)
pfun <- function(x){predict(x, newdata = newdata, type = 'response')}
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =',tg))
legend(4, .7, levels(AF(data$chick[data$target == tg & data$background == bk])), col = cls[which(	levels(AF(data$chick)) %in% levels(AF(data$chick[data$target == tg & data$background == bk])))], pch = c(22,24)[as.numeric(data$sex[data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) & data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))] )],
cex = 1, bty = 'n', lwd = 1, lty = as.numeric( subset(data, chick %in% levels(AF(data$chick[data$target == tg & data$background == bk])) & data$Colour.difference == max(data$Colour.difference[data$chick %in% levels(AF(data$chick[data$target == tg & data$background == bk]))]) )$batch ) )
if(bk == 'green' & tg == 'diff'){
legend('bottomright', legend = c('Male', 'Female', paste('Batch',c('A','B','C','D'))),
col = c(2*(2:1), rep(1, 4)), lty = c(1,1,1:4), pch = c(24,22,rep(NA,4)), cex = 0.7)
}
for(ck in levels(newdata$chick)){
if(sum(data$background == bk & data$chick == ck & data$target == tg)){
sx <- unique(subset(data, chick == ck)$sex)
bc <- unique(subset(data, chick == ck)$batch)
xx <- subset(newdata, background == bk & chick == ck & target == tg & sex == sx & batch == bc)
yy <- lme2.pred[newdata$background == bk & newdata$chick == ck & newdata$target == tg & newdata$sex == sx & newdata$batch == bc]
ORDER <- order(xx$Colour.difference)#Order!
lines(xx$Colour.difference[ORDER], yy[ORDER], col = cls[which(levels(AF(data$chick)) == ck)], lty = which(unique(subset(data, chick == ck)$batch) == levels(newdata$batch)), lwd = 0.5 )
points(data$Colour.difference[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], data$pcorr[data$background == bk & data$chick == ck & data$target == tg & data$sex == sx & data$batch == bc], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg & data$chick == ck])], bg = 'white', col = cls[which(levels(AF(data$chick)) == ck)], lwd = 2)
}
}
}
ndata <- expand.grid(Colour.difference =xseq, background=unique(data$background), target=unique(data$target))
prd <- predict(lme2, newdata = newdata, type="response", re.form = NA)
pfun <- function(x){predict(x, newdata = newdata, type = 'response')}
hw <- c(2,2)
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
bktg <- data.frame(bk = levels(data$background)[c(1,2,2,1)],
tg = rev(levels(newdata$target))[c(1,2,1,2)])
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct", xlim=c(0, 6), ylim=c(0.4, 1), main = paste('background =',bk, ', target =', tg))
xx <- subset(estcurve, background == bk & target == tg)$Colour.difference
yy <- subset(estcurve, background == bk & target == tg)$x
threshness <-abs(yy - 0.65)
threshx <- mean(xx[threshness %in% quantile(threshness, unlist(threshquant[2 - i %% 2])) ])
print(threshx)
polygon(c(subset(CI.02.5, background == bk & ndata$target == tg)$Colour.difference, rev(subset(CI.97.5, background == bk & ndata$target == tg)$Colour.difference)), c(subset(CI.02.5, background == bk & ndata$target == tg)$x,rev(subset(CI.97.5, background == bk & ndata$target == tg)$x)) , col = 'gray', border = rgb(0,0,0,0))
# lines(xx[ORDER], yy[ORDER], col = 'black', lty = 1, lwd = 5)
lines(xx, yy, col = 'black', lty = 1, lwd = 1)
points(data$Colour.difference[data$background == bk & data$target == tg], data$pcorr[data$background == bk & data$target == tg], pch = c(22,24)[as.numeric(data$sex[data$background == bk & data$target == tg])], bg = 'white', col = rgb(0,0,0,0.3), lwd = 2)
lines(rep(threshx, 2), c(0.36, 0.65), lty = 2)
lines(c(-0.25,threshx), rep(0.65,2), lty = 2)
}
legend('bottomright', legend = c('Male', 'Female'),
col = c(1,1), pch = c(24,22), lwd = c(2,2))
std.err <- apply(boot$t, 2, stqlog)#standard error for each
CI.lo.se <- plogis(qlogis(prd) - std.err)#lower se bound (parametric)
CI.hi.se <- plogis(qlogis(prd) + std.err)#upper se bound (parametric)
bootsdata.se <- cbind(newdata, CI.lo.se, CI.hi.se)
CI.lo.se. <- with(bootsdata.se, aggregate(CI.lo.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
CI.hi.se. <- with(bootsdata.se, aggregate(CI.hi.se, list(Colour.difference = Colour.difference, background = background, target = target), lgtmean))
thresholder <- function(xx,yy,lev){
diff. <- sort(yy-lev)
close. <- min(abs(diff.))
if(sign(diff.[abs(diff.) == close.]) == 0){
return(	xx[which(abs(diff.) == close.) + c(0)]	)
}else{
if(sign(diff.[abs(diff.) == close.]) == 1){
if(which(abs(diff.) == close.) == 1){
return(	xx[1])
}else{
ab. <-  xx[which(abs(diff.) == close.) + c(-1,0)]
}
}else{
ab. <-  xx[which(abs(diff.) == close.) + c(0,1)]
}#if(sign(diff.[abs(diff.) == close.]) == 1)
ty. <- yy[xx %in% ab.]
xxt. <- seq(min(ab.), max(ab.), length.out = 10^3)
yyt. <- (xxt.-min(ab.))*diff(ty.)/diff(ab.) + min(ty.)
return(	mean(xxt.[round(yyt.,2) == lev])	)
}
}
par(mfrow = c(hw), mai = .75*c(.8,1,.5,0))
for(i in 1:dim(bktg)[1]){
bk <- bktg$bk[i]
tg <- bktg$tg[i]
plot(NULL, xlab="Colour difference", ylab="Proportion correct",
xlim=c(0, 6),  ylim=c(0.4, 1),
main = paste('background =',bk, ', target =', tg))
abline(h = 0.65, lty = 2, lwd = 0.5)
x1 <- subset(estcurve, background == bk & target == tg)$Colour.difference
y1 <- subset(estcurve, background == bk & target == tg)$x
xx <- sort(unique(subset(CI.lo.se., background == bk & target==tg)$Colour.difference ))
yy.lo <- sort(unique(	subset(CI.lo.se., background == bk & target == tg)$x	))
yy.hi <- sort(unique(	subset(CI.hi.se., background == bk & target == tg)$x	))
lines(xx, yy.lo)
lines(xx, yy.hi)
lines(x1, y1, col = 'darkgreen')
assign(paste0('t.', tg, bk), thresholder(x1,y1,0.65))
lines(rep(get(paste0('t.', tg, bk)),2), c(0.38, 0.65), lty = 2, col = 'green')
assign(paste0('t.se.lo.', tg, bk), thresholder(xx,yy.hi,0.65))
lines(rep(get(paste0('t.se.lo.', tg, bk)),2), c(0.38, 0.65), lty = 2,col ='red')
assign(paste0('t.se.hi.', tg, bk), thresholder(xx,yy.lo,0.65))
lines(rep(get(paste0('t.se.hi.', tg, bk)),2), c(0.38, 0.65), lty = 2,col ='blue')
}
#the "binomial" 65% threshold
#JND for chickens discriminating orange colours on an orange background
round(	c(	t.sameorange,
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
)
#JND on a green background
round(	c(	t.diffgreen,
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
round(	c(	t.sameorange,
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2)
)
round(	c(	t.diffgreen,
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
t.sameorange
diff(round(	c(
t.se.lo.sameorange,
t.se.hi.sameorange	),	2))
diff(round(	c(
t.se.lo.diffgreen,
t.se.hi.diffgreen	),	2)
)
diff(round(	c(
t.se.lo.samegreen,
t.se.hi.samegreen	),	2)
)
diff(round(	c(
t.se.lo.difforange,
t.se.hi.difforange	),	2)
)
save.image("C:/Users/seano/Github/Olsson_colour_discrimination/Non-psychometric_MLE.Rdata.RData")
knitr::opts_chunk$set(echo = TRUE)
#install.packages(c('boot','nonpsych4','MASS','nonpsychrTest','DHARMa'))
library(readr)
library(boot)
library(lme4)
library(MASS)
library(nonpsychrTest)
knitr::opts_chunk$set(echo = TRUE)
library('readr')
library('boot')
library('lme4')
library('MASS')
library('lmerTest')
library('DHARMa')
col.dta <- read_delim('colour_discriminate_short_format.txt', delim='\t')
data <- col.dta
data$stimuli <- factor(data$stimuli)
data$target <- with(data, ifelse(background == stimuli, 'same', 'diff'))
data$target <- as.factor(data$target)
data$background <- factor(data$background)
data$ind <- factor(data$ind)
data$batch <- as.factor(data$batch)
data$chick <- paste0(data$ind, data$batch)
resplot <- function(mod){
#are residuals normally distributed
hist(residuals(mod), prob = T, xlab = formula(mod), main = paste('Residuals for',(formula(mod)[3])))# this actually looks OK to me
lines(density(residuals(mod)), col = 'red')
lines(seq(min(residuals(mod)),max(residuals(mod)), length.out = 10^3), dnorm(seq(min(residuals(mod)),max(residuals(mod)), length.out = 10^3), 0, sd(residuals(mod))), col = 'blue')
legend('topright', legend = c('kernel density', 'fitted normal'), lty = 1, col = c('red', 'blue'))
boxplot(residuals(mod),
add = T, axes = F, horizontal = T, cex = 0.5, outline = T, border = rgb(0,0.1,0,0.7), at = par('yaxp')[2]*0.1,
pars = list(boxwex = par('yaxp')[2]*0.3, staplewex = par('yaxp')[2]*0.5, outwex = par('yaxp')[2]*0.05))#
}
nonpsych1 <- glmer(cbind(corr,incorr)~Colour.difference*background*target*sex + (1+Colour.difference|chick)+ (1+Colour.difference*background|batch), data = data, family = binomial(link = 'logit'))
print(.Machine$double.eps * 10^8)
nonpsych2 <- glmer(cbind(corr,incorr)~Colour.difference*background*target*sex + (1+Colour.difference|chick)+ (1+Colour.difference*background|batch), data = data, family = binomial(link = 'logit'), control = glmerControl(tol = .Machine$double.eps * 10^8))
nonpsych0 <- glmer(cbind(corr,incorr)~1 + (1|chick)+ (1|batch), data = data, family = binomial(link = 'logit'))
anova(nonpsych0, nonpsych1, nonpsych2, test = 'Chisq')
anova(nonpsych0, nonpsych2, test = 'Chisq')
AIC(nonpsych0, nonpsych1, nonpsych2) #
resplot(nonpsych2)#looks good
shapiro.test(residuals(nonpsych2)) # even passes a Shapiro-Wilk test
simulateResiduals(nonpsych2,  n=10^3, plot = T, refit = T)
mtext(formula(nonpsych2), side = 3, outer = F, line = 1)
summary(nonpsych2)
anova(nonpsych2)[order(anova(nonpsych2)$`F value`),]
nonpsych.a<- update(nonpsych2,.~.-Colour.difference:background:target:sex)#4way
formula(nonpsych.a)
nonpsych.b<- update(nonpsych.a,.~.-Colour.difference:target:sex)#3way
formula(nonpsych.b)
nonpsych.c<- update(nonpsych.b,.~.-Colour.difference:background:sex )#3way
formula(nonpsych.c)
nonpsych.d<- update(nonpsych.c,.~.-Colour.difference:background:target )#3way
load("C:/Users/seano/Github/Olsson_colour_discrimination/Non-psychometric_MLE/Non-psychometric_MLE.RData")
t.se.hi.diffgreen
library(rstan)
knitr::opts_chunk$set(echo = TRUE)
library('rstan')
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
Sys.setenv(LOCAL_CPPFLAGS = '-march=corei7 -mtune=corei7')
library('brms')
